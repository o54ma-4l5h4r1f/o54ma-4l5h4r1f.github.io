---
sort : 3
---

# ELF Analysis

from a CTF player perspective ^^. 

Before we start, just want to mention the gcc options and what they do:
```bash
-pie                    # Enable ASLR   (Default)
-no-pie                 # Disable ASLR 

-Wl,-z,relro,-z,now     # Full RELRO
-Wl,-z,relro,-z         # Partial RELRO (Default)
-Wl,-z,norelro          # No RELRO

-fstack-protector       # Enable canaries 
-fno-stack-protector    # Disable canaries  

-z execstack            # NX disabled   

-s                      # Stripped, remove the relocation information along with the symbol table
-static                 # Statically link all the included libraries

-m32
-m64
```

## Static analysis 

### Find glibc version
The GNU C Library project provides the core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel.

So if you managed to know the ubuntu version the binary is running on. you could find the libc versoin that the binary uses, which could help in revealing some exploits

[glibc/versions](https://repology.org/project/glibc/versions)

```note
some ctf challenges provide a Dockerfile, which could tell the version of ubuntu used. 
```

```bash
# To find glibc version on your system
$ ldd --version
```


### $(file) Command
```bash
$ gcc Test.c -o binary
$ file binary 
binary: ELF '64-bit LSB' shared object, x86-64, version 1 (SYSV), 'dynamically linked', interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=168aeeeaf02232025c069bf069d9304b9337a959, for GNU/Linux 3.2.0, 'not stripped'

$ gcc Test.c -o binary -s
$ file binary 
binary: ELF '64-bit LSB' shared object, x86-64, version 1 (SYSV), 'dynamically linked', interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8df0b7e976362d9615d1ae74f92b856b9e7cc843, for GNU/Linux 3.2.0, 'stripped'

$ gcc Test.c -o binary -s -static
$ file binary 
binary: ELF '64-bit LSB' executable, x86-64, version 1 (SYSV), 'statically linked', BuildID[sha1]=1dfba00f274e9fef1e65dc0a1a9fb50382960116, for GNU/Linux 3.2.0, 'stripped'
```




---






### Patch the binary !! 







---




### CheckSec 
```bash
$ checksec binary
[*] '/tmp/a.out'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

#### FULL RELRO vs. Partial RELRO


RELRO is a generic exploit `mitigation technique` to harden the `data sections` of an ELF binary or process.

From an attackers point-of-view, `partial RELRO` makes almost no difference, other than it forces the `GOT` to come before the `BSS` in memory,

eliminating the risk of a `buffer overflows` on a global variable overwriting `GOT`.

---

`Full RELRO` makes the entire GOT `read-only` which removes the ability to perform a "GOT overwrite" attack



```c
// main.c
#include<stdio.h>
int main(){

    printf("Hello World\n");

return 0;
}
```

```bash
$ gcc main.c        # Partial RELRO 
$ r2 a.out

    [0x00001050]> iS
    [Sections]

    nth paddr        size vaddr       vsize perm name
    ―――――――――――――――――――――――――――――――――――――――――――――――――
    0   0x00000000    0x0 0x00000000    0x0 ---- 
    1   0x00000318   0x1c 0x00000318   0x1c -r-- .interp
    2   0x00000338   0x20 0x00000338   0x20 -r-- .note.gnu.property
    3   0x00000358   0x24 0x00000358   0x24 -r-- .note.gnu.build-id
    4   0x0000037c   0x20 0x0000037c   0x20 -r-- .note.ABI-tag
    5   0x000003a0   0x24 0x000003a0   0x24 -r-- .gnu.hash
    6   0x000003c8   0xa8 0x000003c8   0xa8 -r-- .dynsym
    7   0x00000470   0x8d 0x00000470   0x8d -r-- .dynstr
    8   0x000004fe    0xe 0x000004fe    0xe -r-- .gnu.version
    9   0x00000510   0x30 0x00000510   0x30 -r-- .gnu.version_r
    10  0x00000540   0xc0 0x00000540   0xc0 -r-- .rela.dyn
    11  0x00000600   0x18 0x00000600   0x18 -r-- .rela.plt
    12  0x00001000   0x17 0x00001000   0x17 -r-x .init
    13  0x00001020   0x20 0x00001020   0x20 -r-x .plt                   # .plt
    14  0x00001040    0x8 0x00001040    0x8 -r-x .plt.got               # .plt.got
    15  0x00001050  0x103 0x00001050  0x103 -r-x .text                  # .text
    16  0x00001154    0x9 0x00001154    0x9 -r-x .fini
    17  0x00002000   0x10 0x00002000   0x10 -r-- .rodata
    18  0x00002010   0x2c 0x00002010   0x2c -r-- .eh_frame_hdr
    19  0x00002040   0xac 0x00002040   0xac -r-- .eh_frame
    20  0x00002dd0    0x8 0x00003dd0    0x8 -rw- .init_array
    21  0x00002dd8    0x8 0x00003dd8    0x8 -rw- .fini_array
    22  0x00002de0  0x1e0 0x00003de0  0x1e0 -rw- .dynamic
    23  0x00002fc0   0x28 0x00003fc0   0x28 -rw- .got                   # .got          it's writable
    24  0x00002fe8   0x20 0x00003fe8   0x20 -rw- .got.plt               # .got.plt      it's writable
    25  0x00003008   0x10 0x00004008   0x10 -rw- .data                  # .data         it's writable
    26  0x00003018    0x0 0x00004018    0x8 -rw- .bss                   # .bss          it's writable
    27  0x00003018   0x1e 0x00000000   0x1e ---- .comment
    28  0x00003038  0x360 0x00000000  0x360 ---- .symtab
    29  0x00003398  0x1da 0x00000000  0x1da ---- .strtab
    30  0x00003572  0x11a 0x00000000  0x11a ---- .shstrtab
```




---





#### PIE vs. ASLR 

`Address Space Layout Randomisation` (ASLR), every time you run a binary, libc (and other libraries) get `loaded` into a different memory address.

simply it randomizes everything in the proccess except hte code section

`Position Independent Executable` (PIE), randomizes the code section only, like main address and other functions addresses.


```note
The main difference is that PIE can be compiled into the binary while the presence of ASLR is completely dependant on the environment running the binary.
```

> to Disable ASLR on your system :
```bash
$ sudo bash -c "echo 0 > /proc/sys/kernel/randomize_va_space"

$ # sudo bash -c "echo 2 > /proc/sys/fs/suid_dumpable"              ?? 
```



---



#### NX / DEP 

Data Execution Prevention (`DEP`) or No-Execute (`NX`), 
When this option is enabled, it works with the processor to help prevent buffer overflow attacks by `blocking code execution` from memory that is marked as non-executable.




#### Stack Canaries

One way to prevent the stack-based buffer overflow, it's a secret value placed on the stack which `changes every time` the program is started. `Prior` to a function return,

the stack canary is checked and if it appears to be modified, the program exits immeadiately.












































### Ghidra 