---
sort : 5
---

# OS

Here are some of the commonly known CPU architectures:

* `x86`: The most common CPU architecture used in personal computers, laptops, and servers. It was developed by Intel and later adopted by AMD and other manufacturers.

* `ARM`: This architecture is used primarily in mobile devices, embedded systems, and IoT devices. ARM processors are known for their energy efficiency and low power consumption.

* `PowerPC`: This architecture was used by Apple in its Macintosh computers before transitioning to Intel processors. It is also used in some embedded systems and high-performance computing applications.

* `MIPS`: This architecture is used in a variety of embedded systems and networking equipment. It is also used in some gaming consoles.


```
uname -a
```

---

Yes, there are several branches of the ARM architecture. Here are some of the commonly known ones:

ARMv6: This branch of the architecture is used in older ARM-based devices, such as the Raspberry Pi Model B and the iPhone 3G.

ARMv7: This branch of the architecture is used in a wide range of devices, including smartphones, tablets, and embedded systems. It includes several different profiles, including ARMv7-A, which is used in high-performance applications, and ARMv7-R, which is used in real-time applications.

ARMv8: This branch of the architecture includes the ARMv8-A profile, which supports 64-bit processing and is used in high-performance computing applications, as well as the ARMv8-R profile, which is used in safety-critical systems.

ARMv9: This branch of the architecture was announced in 2021 and is expected to be used in a wide range of devices, from smartphones to supercomputers. It includes features such as enhanced security and machine learning acceleration.

In addition to these branches, ARM also offers several other specialized architectures, such as ARMv8-M, which is designed for microcontrollers, and ARMv8.1-M, which is designed for IoT devices.

---	

### 64-bits vs. 32-bits Processors 

There are two primary processor architectures used in today's environments: 32-bit (x86) and 64-bit (x86-64, IA64 (Intel Arch), and AMD64). These architectures differ in the `datapath width`, `registers size`, and `memory address width` that the processor is able to work with.

and each cpu arch has it's own instructions set !! 


When we say a "32-bit system," we are typically referring to the size of the processor's registers, which are a type of fast memory inside the CPU that hold data that the CPU is currently working with. The term "32-bit" refers to the size of these registers, which are capable of holding 32 bits of data at a time.

---

A 64-bit CPU is capable of addressing much more memory than a 32-bit CPU. Specifically, a 32-bit CPU can address up to 4GB of RAM, while a 64-bit CPU can address much more memory, typically up to several terabytes.


---

A 64-bit processor has a `64-bit address bus`, which means it is capable of addressing up to 2^64 memory locations. This allows a 64-bit processor to access much more memory than a 32-bit processor, which has a 32-bit address bus and can address up to 2^32 memory locations.

The amount of memory that can be addressed by a processor is determined by the width of the address bus. Each memory location has a unique address that is stored in the processor's address bus, and the width of the address bus determines the range of memory addresses that can be accessed.

With a 64-bit address bus, a 64-bit processor can address up to 16 exabytes (EB) of memory, which is a massive amount of memory. However, it's important to note that the amount of memory that can actually be installed and used by a system depends on other factors, such as the amount of `physical memory slots` on the motherboard and the `limitations of the operating system`.

Here are the maximum supported RAM limits for some popular operating systems:

    Windows 10 Home: 128 GB
    Windows 10 Pro: 2 TB
    Windows 10 Enterprise: 2 TB
    Windows Server 2019 Essentials: 64 GB
    Windows Server 2019 Standard: 24 TB
    macOS Monterey: 2 TB
    Ubuntu 20.04 LTS: 128 TB
    CentOS 7: 768 GB
    Debian 10: 32 TB

It's worth noting that the maximum amount of RAM that an operating system can support depends on several factors, including the version of the operating system, the type of processor being used, and the specific hardware configuration of the system. Additionally, not all applications are capable of using large amounts of RAM, so in some cases, there may be `diminishing returns` on performance as more RAM is added.


when you continuously add more and more input in a productive process, it will actually yield progressively smaller increases in output.

---	

In the 1990s, Intel introduced the 80386 processor, which used a 32-bit memory word size. This allowed the processor to access memory in 32-bit chunks, or words, at a time, which greatly increased the amount of memory that could be addressed and the performance of the system.

Today, modern x86 processors typically use a 64-bit memory word size, which allows them to access much larger amounts of memory than older processors. This has become increasingly important as applications and operating systems have become more memory-intensive and require more memory to run effectively.


---


elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 pei-i386 pe-x86-64 pei-x86-64 elf64-little elf64-big elf32-little elf32-big pe-bigobj-x86-64 pe-i386 srec symbolsrec verilog tekhex binary ihex


---

# X86-64 Architecture Guide


|     Register     |                     Purpose                     | Saved across calls |
|:----------------:|:-----------------------------------------------:|:------------------:|
| %rax             | temp register; return value                     | No                 |
| %rbx             | callee-saved                                    | Yes                |
| %rcx             | used to pass 4th argument to functions          | No                 |
| %rdx             | used to pass 3rd argument to functions          | No                 |
| %rsp             | stack pointer                                   | Yes                |
| %rbp             | callee-saved; base pointer                      | Yes                |
| %rsi             | used to pass 2nd argument to functions          | No                 |
| %rdi             | used to pass 1st argument to functions          | No                 |
| %r8              | used to pass 5th argument to functions          | No                 |
| %r9              | used to pass 6th argument to functions          | No                 |
| %r10-r11         | temporary                                       | No                 |
| %r12-r15         | callee-saved registers                          | Yes                |


```tip
call fun(di, si, dx, cx, 8, 9)
```





## Examples
```nasm
cmp    bl, 78h
jg     addr    ; if bl > 78h, jump to addr
```



```

rep stosq qword [rdi]  {0x0}  {0x0}  {0x0}                 ????????????????????/

```




|        Opcode        |                                                                                                           Description                        |
|:--------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|
| Copying values       |                                                                                                                                              |
| mov src, dest        | Copies a value from a register, immediate value or memory address to a register or memory address.                                           |
| cmove %src, %dest    | Copies from register %src to register %dest if the last comparison operation had the corresponding result.                                   |
| cmovne %src, %dest   |  (cmove: equality, cmovne: inequality, cmovg: greater, cmovl: less, cmovge: greater or equal, cmovle: less or equal)                         |
| cmovg %src, %dest    |                                                                                                                                              |
| cmovl %src, %dest    |                                                                                                                                              |
| cmovge %src, %dest   |                                                                                                                                              |
| cmovle %src, %dest   |                                                                                                                                              |

| Stack management     |                                                                                                                                              |
| leave                | Removes local variables from the stack frame by restoring the old values of %rsp and %rbp.                                                   |
| push src             | Decreases %rsp and places src at the new memory location pointed to by %rsp. Here, src can be a register, immediate value or memory address. |
| pop dest             | Copies the value stored at the location pointed to by %rsp to dest and increases %rsp. Here, dest can be a register or memory location.      |

| Control flow         |                                                                                                                                              |
| call target          | Jump unconditionally to target and push return value (current PC + 1) onto stack.                                                            |
| ret                  | Pop the return address off the stack and jump unconditionally to this address.                                                               |
| jmp target           | Jump unconditionally to target, which is specified as a memory location (for example, a label).                                              |
| je target            | Jump to target if the last comparison had the corresponding result (je: equality; jne: inequality).                                          |
| jne target           |                                                                                                                                              |

| Arithmetic and logic |                                                                                                                                              |
| add src, dest        | Add src to dest.                                                                                                                             |
| sub src, dest        | Subtract src from dest.                                                                                                                      |
| imul src, dest       | Multiply dest by src.                                                                                                                        |
| idiv divisor         | Divide rdx:rax by divisor.  Store quotient in rax and store remainder in rdx.                                                                |
| shr reg              | Shift reg to the left or right by value in cl (low 8 bits of rcx).                                                                           |
| shl reg              |                                                                                                                                              |
| ror src, dest        | Rotate dest to the left or right by src bits.                                                                                                |
| cmp src, dest        | Set flags corresponding to whether dest is less than, equal to, or greater than src                                                          |



src and dest ?????? swap them ?? 










see this https://www.thesecuritybuddy.com/reverse-engineering/what-is-fs0x28-in-x86-assembly/2/


## Ref

* http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html