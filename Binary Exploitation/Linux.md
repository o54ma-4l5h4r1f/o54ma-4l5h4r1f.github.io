---
sort : 2
---

# Linux & C/C++ 

## File handles (file descriptors) in Linux
`File descriptor` is integer that uniquely identifies an open file of the process.

in simple words, when you open a file, the operating system creates an entry to represent that file and store the information about that opened file. So if there are 100 files opened in your OS then there will be 100 entries in OS (somewhere in kernel). These entries are represented by `integers` like (...100, 101, 102....). This entry number is the file descriptor. So it is just an integer number that uniquely represents an opened file for the process. If your process opens 10 files then your Process table will have 10 entries for file descriptors.

Similarly, when you open a network socket, it is also represented by an integer and it is called `Socket Descriptor`.

```c
int main()
{
	
	pid_t pid = getpid();
	printf("pid = %d\n", pid);	

    // int open(const char *pathname, int flags);
	int file_fd = open("file.txt", O_RDONLY);                   // open file        file_fd = 3 

    // FILE *fopen(const char *pathname, const char *mode); 
    FILE *fp = fopen("file.txt", "r");

    // int socket(int domain, int type, int protocol);
	int sock_fd = socket(AF_INET, SOCK_STREAM, 0);              // open socket      sock_fd = 4 

	int b; 
	scanf("%d", &b);

	return 0;
}

// Run the code to get the PID = 12345 for example
```

```bash
$ tty
/dev/pts/0


$ ls -la /proc/12345/fd
/proc/12345/fd:
total 0
dr-x------ 2 user user  0 Oct  2 20:53 .
dr-xr-xr-x 9 user user  0 Oct  2 20:53 ..
lrwx------ 1 user user 64 Oct  2 20:53 0 -> /dev/pts/0
lrwx------ 1 user user 64 Oct  2 20:53 1 -> /dev/pts/0
lrwx------ 1 user user 64 Oct  2 20:53 2 -> /dev/pts/0
lr-x------ 1 user user 64 Oct  2 20:53 3 -> /tmp/file.txt
lr-x------ 1 user user 64 Oct  2 20:53 4 -> /tmp/file.txt
lrwx------ 1 user user 64 Oct  2 20:53 5 -> 'socket:[273926]'
```





```note
When any process starts, then that process file descriptors tableâ€™s fd 0, 1, 2 open `automatically`.

0 --> stdout
1 --> stdin
2 --> stderr

So (stdout, stdin, stderr) are files objects (FILE *) that opened by default when the process starts,
hence, we can read from them or write on them ... see below !! 
```

```c

int main(){

    // int fprintf(FILE *stream, const char *format, ...);
    fprintf(stdout, "hello world\n");
    fprintf(stderr, "erorr world\n");

    // int fscanf(FILE *stream, const char *format, ...);
	int a;
	fscanf(stdin, "%d", &a);
	printf("%d\n", a);

    return 0;
}
```


# Input-Output Redirection

`|`         redirect the `output` of the first command can be used `as` the `input` of the second command.

`<` `0<`    redirect the `input` to the first command `from` a file
`>` `1>`    redirect the `output` of first command `to` a file
    `2>`    redirect the `stderr` of first command `to` a file
    `&>`    redirect the `stdout & stderr` of first command `to` a file

`<>` 	    This operator is used for specified files as `both` standard `input` and standard `output`.
`>&`	    redirects the `output` of one file to another.
`<&` 	    redirects the `input` of one file to another.
`2>&1` 	    redirects standard `error` to standard `output`.
`1>&2` 	    This operator is used for redirecting standard `output` to standard `error`







---





## Stream in C  
the stream is just a generic name, used as a uniform way of interfacing with different sources of `sequential data`, like files, sockets, keyboards, USB ports, printers or whatever. 

```c
// prototype 
int fputs(const char *s, FILE *stream);         // stream here is a pointer to a file object 
```





---







# FFlush Stdin & Stdout
The operating system may initially put the output data in a `temporary buffer` before writing it to an output `stream` or `FILE` like stdout.

Buffering works in such a way that the contents of an output buffer are only written to the stdout stream or FILE object once the buffer is `full`, or there is a `new line` character at the end of it

`fflush` function make sure that the current state of the `temporary buffer` is immediately printed to the console and written to the stdout stream.

```c
#include <stdio.h>

int main()
{
    printf("HII");          // the string may not be printed cuz the temporary buffer not filled yet 
    fflush(stdout);         // flush the toilet

}
```


why flusing the stdin ?? 

in the example below the scanf reads string up to newline and add it into the tmp buffer, after entering the second loop the scanf won't accept any input, since the tmp buffer not empty yet (never saw a newline), so in this case we force the stdin to be flushed to accept new input every time ^^.

```c
int main()
{
    char str[20];
    int i;
    for (i=0; i<2; i++)
    {
        scanf("%[^\n]s", str);          // read up to \n, and \n included !!
        printf("%s\n", str);
        // fflush(stdin);
    }
    return 0;
}
```

```note
flush is only used with output streams. 
```

The most portable solution for flushing stdin would probably be something along the lines of the following:

```c
// fflush(stdin);
int c;
while ((c = getchar()) != '\n' && c != EOF);
```



























size_t existed at least since C89 but the respective format specifier %zu (specifically the length modifier z) was added to the standard only since C99.

So, if you can't use C99 (or C11) and had to print size_t in C89, you just have to fallback to other existing types, such as:

printf("%lu\n", (unsigned long)n);
